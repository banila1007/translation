### 에러 처리

#### 기본 에러 값

무결성은 중요하다. 무결성 만큼 중요한것은 없다. 에러 처리는 그러한 무결성의 일부이다. 우리가 매일 하는 일에서 큰 부분을 차지한다. 작성하고자 하는 코드 자체의 일부로 여겨져야 한다. 먼저, 언어에서 제공하는 기본 에러 타입 구현의 동작에 대해 살펴보고자 한다.

```go
package​ main
import​ ​"fmt"
```

http://golang.org/pkg/builtin/#error

이것은 언어 자체에 포함되어 있기 때문에 노출되지 않은(unexported) 타입처럼 보인다. Error 라는 문자열 한 개를 반환하는 한 개의 기능에만 접근이 가능하다. 에러 처리는 사용자 코드 테스팅시에 항상 에러 인터페이스를 이용하기 위해 디커플링 되어 있다.

Go는 에러를 단지 값으로만 취급한다. 인터페이스 디커플링을 통해 값을 평가하게 된다. 에러 처리를 디커플링 하는 것은 지속적인 변경이 코드 전반에 걸쳐 광범위한 영향을 야기하기 때문이다. 에러를 다룰 때 인터페이스를 최대한 이용하는 것이 중요하다.

```go
type​ error ​interface​ {
    Error() ​string
}
```

http://golang.org/src/pkg/errors/errors.go

이것은 에러 패키지로부터 제공되는 기본적이며 구체적인 타입이다. 타입은 노출되지 않으면서 노출되지 않은 필드를 가진다. 이 방법은 사용자의 에러 판정을 구조화 할 수 있는 충분한 컨텍스트를 제공한다.

사용자들에게 에러 상황을 어떻게 다룰 지 의사결정할 수 있도록 호출 시 에러 처리에 대해 충분한 내용을 제공해야 한다.

```go
type​ errorString ​struct​ {
    s ​string
}
```

http://golang.org/src/pkg/errors/errors.go

포인터를 매개변수로 받아 문자열을 반환한다. 사용자가 이 메소드를 호출하여 실패상황에 대한 정보를 지닌 문자열을 얻어낼 수 있다.

이 메소드는 에러에 대한 정보를 로깅하는 데 사용한다.

```go
func​ (e *errorString) ​Error​() ​string​ {
    return​ e.s
}
```

http://golang.org/src/pkg/errors/errors.go

New는 주어진 문자열에서 에러 인터페이스를 반환한다. 사용자가 New를 호출하면, text로 넘어온 값을 포함하는 errorString 값이 생성된다. 해당 타입의 실체에 대한 주소를 반환하기 때문에, 사용자는 실제 에러 내용을 가리키는 \*errorString을 통해 에러 인터페이스 값을 얻을 수 있다. 에러 처리는 이와 같은 방식으로 디커플링될 수 있다.

```go
func​ ​New​(text ​string​) ​error​ {
    return​ &errorString{text}
}
```

아래는 Go에서 에러를 다루는 전통적인 방식이다. webCall 함수를 호출하고 에러 인터페이스를 변수에 저장하는 예시를 관찰할 것이다.

nil은 Go에서 특별한 값이다. "error != nil"은 타입에 대한 실질적 값이 에러 인터페이스에 들어있는가 확인함을 의미한다. 에러가 nil 값이 아니면 실질적인 값이 저장된 것이기 때문이다. 값이 있는 경우에는 에러를 마주한 것이다.

이제 에러를 처리하고, 에러가 호출 스택 상위에서 누군가가 제어할 수 있도록 해야 하지 않겠는가? 이 부분은 나중에 다루기로 한다.

```go
func​ ​main​() {
    if​ err := webCall(); err != ​nil​ {
        fmt.Println(err)
        return
    }
    fmt.Println(​"Life is good"​)
}
```

웹 요청을 처리하는 webCall 함수.

```go
func​ ​webCall​() ​error​ {
    return​ New(​"Bad Request"​)
}
```

#### 에러 변수

어떤 에러가 반환 되는지 알기 위해 에러 변수를 사용해본다.

```go
package​ main
import​ (
    "errors"
    "fmt"
)
```

소스코드 파일의 최상단을 아래와 같이 작성한다. 명명 규칙 : 에러 변수 명명은 Err로 시작하도록 한다. 사용자들이 접근 가능하도록 (대문자로 작성하여) 노출한다.

아래는 지난 예시 파일에서 살펴 본 에러 인터페이스들에, 값을 할당한 것이다. 에러들에 대한 컨텍스트를 이 변수들이 자체적으로 포함한다. 이 방법은 사용자들이 기본 에러 타입과 그것의 필드에 대한 노출 없이 지속적으로 에러 처리를 사용할 수 있도록 디커플링한다.

요청에 문제가 있는 경우 ErrBadRequest 변수가 반환된다. 301/302가 반환되면 ErrBadRequest 변수가 반환된다.

```go
var​ (
    ErrBadRequest = errors.New(​"Bad Request"​)
    ErrPageMoved = errors.New(​"Page Moved"​)
)
```

```go
func​ ​main​() {
    if​ err := webCall(​true​); err != ​nil​ {
        switch​ err {
        case​ ErrBadRequest:
            fmt.Println(​"Bad Request Occurred"​)
            return
        case​ ErrPageMoved:
            fmt.Println(​"The Page moved"​)
            return
        default​:
            fmt.Println(err)
            return
        }
    }
    fmt.Println(​"Life is good"​)
}
```

웹 요청을 처리하는 webCall 함수.

```go
func​ ​webCall​(b ​bool​) ​error​ {
    if​ b {
        return​ ErrBadRequest
    }
    return​ ErrPageMoved
}
```

```
Bad Request Occurred
```

#### 컨텍스트로써의 타입

컨텍스트를 표현하는 데 에러 인터페이스 값이 충분하지 않을 수 있다. 더 많은 컨텍스트를 필요로 하는 경우가 있을 수 있다. 예를 들어, 네트워킹 문제는 복잡할 수 있다. 에러 변수 자체로는 충분하지 못하다. 에러 변수로 충분하지 못한 경우에는, 커스텀 타입을 통해 문제를 해결해야 한다.


아래 2개 타입은 표준 라이브러리인 JSON 패키지 기반 커스텀 에러 정의 방법이다. 이것이 컨텍스트를 포함하는 타입이다.

http://golang.org/src/pkg/encoding/json/decode.go

```go
package main
import​ (
    "fmt"
    "reflect"
)
```

UnmarshalTypeError은 Go의 특정 타입으로 간주하기 어려운 JSON 값을 표현한다. 명명 규칙 : 타입 명명 시에는 접미사를 Error로 한다.

```go
type​ UnmarshalTypeError ​struct​ {
    Value ​string​ ​// description of JSON value
    Type reflect.Type ​// type of Go value it could not be assigned to
}
```

UnmarshalTypeError은 에러 인터페이스를 구현한다. 포인터 시맨틱(pointer semantics)을 이용한다. 구현 시, 모든 필드가 에러 메시지에서 사용되는가 검증한다. 이렇게 하지 않는다면, 문제가 발생할 것이다. 커스텀 에러 타입에 필드를 추가 해두어도 아래 메소드가 호출될 때 로그가 정상적으로 출력되지 않을 것이기 때문이다. 정말 필요할 때만 이렇게 사용하기로 한다.

```go
func​ (e *UnmarshalTypeError) ​Error​() ​string​ {
    return​ ​"json: cannot unmarshal "​ + e.Value + ​" into Go value of type "​ + e.Type.String()
}
```

InvalidUnmarshalError는 Unmarshal 함수에 유효하지 않은 매개변수가 들어왔음을 알린다. Unmarshal의 매개변수로는 nil이 아닌 포인터가 들어와야 한다. 실제 타입은 Unmarshal 함수가 값에 대한 주소를 받지 않았을 때 반환값에 사용된다.

```go
type​ InvalidUnmarshalError ​struct​ {
    Type reflect.Type
}
```

에러 인터페이스를 구현하는 InvalidUnmarshalError.

```go
func​ (e *InvalidUnmarshalError) ​Error​() ​string​ {
    if​ e.Type == ​nil​ {
        return​ ​"json: Unmarshal(nil)"
    }
    if​ e.Type.Kind() != reflect.Ptr {
        return​ ​"json: Unmarshal(non-pointer "​ + e.Type.String() + ")"
    }
    return​ ​"json: Unmarshal(nil "​ + e.Type.String() + ​")"
}
```

Unmarshal 호출을 위해 사용하는 user 타입.

```go
type​ user ​struct​ {
    Name ​int
}
```

```go
func​ ​main​() {
    var​ u user
    err := Unmarshal([]​byte​(​`{"name":"bill"}`​), u) ​// Run with a value and pointer.
    if​ err != ​nil​ {
        This is a special ​type​ assertion that only works on the ​switch​.
​        switch​ e := err.(​type​) {
        case​ *UnmarshalTypeError:
            fmt.Printf(​"UnmarshalTypeError: Value[%s] Type[%v]\n"​, e.Value, e.Type)
        case​ *InvalidUnmarshalError:
            fmt.Printf(​"InvalidUnmarshalError: Type[%v]\n"​, e.Type)
        default​:
            fmt.Println(err)
        }
        return
    }
    fmt.Println(​"Name:"​, u.Name)
}
```

Unmarshal 함수는 항상 실패할 언마셜을 실험한다. 매개변수 영역을 주목해보면, 첫 번째는 바이트 슬라이스이고, 두 번째는 빈 인터페이스이다. 빈 인터페이스는 기본적으로 어떤 것도 의미하지 않으며, 함수를 통해 어떤 값이든 받을 수 있다. 아래에서는 리플렉션을 이용해 인터페이스에 저장된 값의 실제 타입을 알아내고, 그것이 포인터가 아니거나 nil이 아닌지 평가할 것이다. 결과에 기초하여 다른 에러 타입을 반환한다.

```go
func​ ​Unmarshal​(data []​byte​, v ​interface​{}) ​error​ {
    rv := reflect.ValueOf(v)
    if​ rv.Kind() != reflect.Ptr || rv.IsNil() {
        return​ &InvalidUnmarshalError{reflect.TypeOf(v)}
    }
    return​ &UnmarshalTypeError{​"string"​, reflect.TypeOf(v)}
}
```

컨텍스트 타입을 이용할 때의 결점이 한 가지 있다. 여기서는, 실제 값으로 돌아간다. 구체적인 타입들로 인해 코드에 결합성이 생기게 된다. json 패키지를 작성한 개발자가 구체적 타입들에 대해 변경하면, 예제 코드에도 연쇄적인 영향을 미치게 된다. 에러 인터페이스 디커플링에 의해 보호받지 못한다.

이러한 문제는 가끔 발생할 수 있다. 디커플링을 유지하는 다른 방법은 없을까? 컨텍스트로써의 기능을 살펴보자.

#### 컨텍스트로서의 기능(Behavior as context)

컨텍스트로서의 기능은 사용자 정의 오류를 마치 컨텍스트처럼 다룰 수 있게 해준다. 하지만 타입 단언이 구체인 것으로 돌아가는 건 막는다. 이로써 디커플링(decoupling)의 레벨에서 코드를 유지보수할 수 있게 되었다.

```go
package​ main
import​ (
    "bufio"
    "fmt"
    "io"
    "log"
    "net"
)
```

`client`는 하나의 연결성을 가진다.

```go
type​ client ​struct​ {
    name ​string
    reader *bufio.Reader
}
```

`TypeAsContext`는 `net` 패키지가 반환하는 여러 사용자 정의 오류들을 확인하는 방법을 보여준다.

```go
func​ (c *client) ​TypeAsContext​() {
    for​ {
```

네트워크에서 받아온 데이터를 `reader`를 통해 분리한다.

```go
        line, err := c.reader.ReadString(​'\n'​)
        if​ err != ​nil​ {
```

이 예제는 이전 예제와 마찬가지로 타입을 컨텍스트처럼 쓴다. 여기서 `Temporary`라는 메서드가 중요하다. 만약 이 메서드가 정상적으로 작동한다면 계속 작업을 수행하고 그렇지 않다면 일단 멈춘 후에 다시 시작한다. 아래 모든 케이스는 오직 `Temporary`만을 위한 것이다. 이게 왜 중요한가? 만약 타입 단언을 한다거나 구현된 타입의 잠재적인 기능만 요구한다면, 이것을 컨텍스트로서의 타입을 기능으로서의 타입으로 바꿀 수 있다. 그렇기에 아래의 `temporary`라는 사용자 정의 인터페이스를 만들 수 있다.

```go
            switch​ e := err.(​type​) {
            case​ *net.OpError:
                if​ !e.Temporary() {
                    log.Println(​"Temporary: Client leaving chat"​)
                    return
                }
            case​ *net.AddrError:
                if​ !e.Temporary() {
                    log.Println(​"Temporary: Client leaving chat"​)
                    return
                }
            case​ *net.DNSConfigError:
                if​ !e.Temporary() {
                    log.Println(​"Temporary: Client leaving return chat")
                    return
                }
            default​:
                if​ err == io.EOF {
                    log.Println(​"EOF: Client leaving chat"​)
                    return
                }
            log.Println(​"read-routine"​, err)
            }
        }
    fmt.Println(line)
    }
}
```

`temporary`는 net 패키지에서 `Temporary`라는 메서드가 반환되는 지 확인한다. 왜냐하면 그 중 `Temporary`라는 메서드를 가진 구조체만 있으면 되기때문이다. 그러면 여전히 디커플링 단계에 있으며 계속 인터페이스 레벨에서 작업할 수 있다.

```go
type​ temporary ​interface​ {
    Temporary() ​bool
}
```

`BehaviorAsContext`는 `net` 패키지가 반환할 지도 모르는 있는 인터페이스를 어떻게 확인하는 지 보여준다.

```go
func​ (c *client) ​BehaviorAsContext​() {
    for​ {
        line, err := c.reader.ReadString(​'\n'​)
        if​ err != ​nil​ {
            switch​ e := err.(​type​) {
```

타입 단언을 통해 세가지 경우를 한가지 경우로 줄일 수 있다:
이 구현 타입은 해당 인터페이스를 구현하고 있는 `error` 인터페이스를 가지고 있으며 해당 인터페이스를 정의하고 이용할 수 있다.

```go
            case​ temporary:
                if​ !e.Temporary() {
                    log.Println(​"Temporary: Client leaving return chat")
                    return
                }
            default​:
                if​ err == io.EOF {
                    log.Println(​"EOF: Client leaving chat"​)
                    return
                }
                log.Println(​"read-routine"​, err)
            }
        }
        fmt.Println(line)
    }
}
```

**Lesson:**

Go의 암시적 형변환 덕분에, 원하는 메서드나 기능을 가진 인터페이스를 구현함으로 디커플링 단계에서 유지보수할 수 있고 타입 단언을 이용하는 `switch` 문법에서 구현 타입 대신에 사용할 수 있다.

#### 버그 사냥(Finding the bug)

```go
package​ main
import​ ​"log"
```

`customError`는 빈 구조체이다.

```go
type​ customError ​struct​{}
```

`Error`는 `error` 인터페이스를 구현한다.

```go
func​ (c *customError) ​Error​() ​string​ {
    return​ ​"Find the bug."
}
```

`fail` 함수는 둘 다 `nil` 값을 반환한다.

```go
func​ ​fail​() ([]​byte​, *customError) {
    return​ ​nil​, ​nil
}
```

```go
func​ ​main​() {
    var​ err error
```

만약 `fail`을 호출하면 `nil` 값을 반환할 것이다. 하지만 `error` 인터페이스로써 반환하고 싶지만 `customError` 타입의 `nil` 값을 가질 뿐이다. `customError` 타입은 그저 만들어진 것에 불과하다. 그렇기에 사용자 정의 타입을 직접 사용할 수는 없고 오직 `func fail() ([]byte, error)` 처럼만 사용할 수 있다.

```go
    if​ _, err = fail(); err != ​nil​ {
        log.Fatal(​"Why did this fail?"​)
    }
    log.Println(​"No Error"​)
}
```

#### Wrapping Errors

Error handling has to be part of our code and usually it is bound to logging. The main goal of logging is to debug. We only log things that are actionable. Only log the contexts that are allowed us to identify what is going on. Anything else ideally is noise and would be better suited up on the dashboard through metrics. For example, socket connection and disconnection, we can log these but these are not actionable because we don't necessarily lookup the log for that.

There is a package that is written by Dave Cheney called errors that let us simplify error handling and logging at the same time. Below is a demonstration on how to leverage the package to simplify our code. By reducing logging, we also reduce a large amount of pressure on the heap (garbage collection).

```go
import (
    "fmt"

    "github.com/pkg/errors"
)
```

AppError represents a custom error type.

```go
type​ AppError ​struct​ {
    State ​int
}
```

AppError implements the error interface.

```go
func​ (c *AppError) ​Error​() ​string​ {
    return​ fmt.Sprintf(​"App Error, State: %d"​, c.State)
}
```

```go
func​ ​main​() {
```

Make the function call and validate the error. firstCall calls secondCall calls thirdCall then results in AppError. Start down the call stack, in thirdCall, where the error occurs. This is the root of the error. We return it up the call stack in our traditional error interface value.

Back to secondCall, we get the interface value and there is a concrete type stored inside the value. secondCall has to make a decision whether to handle the error and push up the call stack if it cannot handle. If secondCall decides to handle the error, it has the responsibility of logging it. If not, its responsibility is to move it up. However, if we are going to push it up the call stack, we cannot lose context. This is where the error package comes in. We create a new interface value that wraps this error, add a context around it and push it up. This maintains the call stack of where we are in the code.

Similarly, firstCall doesn't handle the error but wraps and pushes it up. In main, we are handling the call, which means the error stops here and we have to log it.

In order to properly handle this error, we need to know that the root cause of this error was. It is the original error that is not wrapped. Cause method will bubble up this error out of these wrapping and allow us to be able to use all the language mechanics we have.

We are not only able to access the State even though we've done this assertion back to concrete, we can log out the entire stack trace by using %+v for this call.

Use type as context to determine cause. We got our custom error type.

```go
    if​ err := firstCall(​10​); err != ​nil​ {
        switch​ v := errors.Cause(err).(​type​) {
        case​ *AppError:
            fmt.Println(​"Custom App Error:"​, v.State)
```

Display the stack trace for the error.

```go
            fmt.Println(​"\nStack Trace\n********************************"​)
            fmt.Printf(​"%+v\n"​, err)
            fmt.Println(​"\nNo Trace\n********************************"​)
            fmt.Printf(​"%v\n"​, err)
        }
    }
}
```

firstCall makes a call to a secondCall function and wraps any error.

```go
func​ ​firstCall​(i ​int​) ​error​ {
    if​ err := secondCall(i); err != ​nil​ {
        return​ errors.Wrapf(err, ​"firstCall->secondCall(%d)"​, i)
    }
    return​ ​nil
}
```

secondCall makes a call to a thirdCall function and wraps any error.

```go
func​ ​secondCall​(i ​int​) ​error​ {
    if​ err := thirdCall(); err != ​nil​ {
        return​ errors.Wrap(err, ​"secondCall->thirdCall()"​)
    }
    return​ ​nil
}
```

thirdCall function creates an error value we will validate.

```go
func​ ​thirdCall​() ​error​ {
    return​ &AppError{​99​}
}
```

```
Custom App Error: 99
Stack Trace
********************************
App Error, State: 99
secondCall->thirdCall()
main.secondCall
    /tmp/sandbox880380539/prog.go:74
main.firstCall
    /tmp/sandbox880380539/prog.go:65
main.main
    /tmp/sandbox880380539/prog.go:43
runtime.main
    /usr/local/go-faketime/src/runtime/proc.go:203
runtime.goexit
    /usr/local/go-faketime/src/runtime/asm_amd64.s:1373
firstCall->secondCall(10)
main.firstCall
    /tmp/sandbox880380539/prog.go:66
main.main
    /tmp/sandbox880380539/prog.go:43
runtime.main
    /usr/local/go-faketime/src/runtime/proc.go:203
runtime.goexit
    /usr/local/go-faketime/src/runtime/asm_amd64.s:1373

No Trace
********************************
firstCall->secondCall(10): secondCall->thirdCall(): App Error, State: 99
```
